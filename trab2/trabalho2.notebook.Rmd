---
title: "R Notebook"
output: html_notebook
---

```{r}
library(igraph)
library(conflicted)
library(magrittr)
library(icecream)
library(restorepoint)

```

Clique com 10 nodos

```{r}
graph.full(10, directed = F) -> g
g |> plot()
```

```{r}
get_neighbors <- function(graph, node) {
  # dps n da pra faer vetor deles se n fizer isto
  neighbors(graph, node) %>% as.integer()
}

# 0 <= p <= 1
# 1 <= n_ligacoes
random_walk_model_iter <- function(graph, p = 0.8, n_ligacoes = 3,debug_ = T, i = NULL) {
  if(debug_) {
    ic_enable()
  } else {
    ic_disable()
  }
  if (i %>% is.null() %>% isFALSE()) {
    restore.point(paste0("iter_",i), to.global = TRUE)
  }
  graph %<>% add_vertices(1)
  # vars
  nodo_ligado      <- sample(1:(vcount(graph) - 1), 1)
  ic(nodo_ligado)
  nodo_novo        <- vcount(graph)
  ic(nodo_novo)
  

  neighbors_de_ligado <- get_neighbors(graph, nodo_ligado)
  ic(neighbors_de_ligado)
  graph %<>% add_edges(c(nodo_novo, nodo_ligado))
  
  # dps de ter o primeiro link, comecar o loop
  for (i in 2:n_ligacoes) {
    ic(i)
    # escolher um vizinho do nodo ligado (ainda não escolhido)
    nodo_para_aceitar <- setdiff(neighbors_de_ligado, get_neighbors(graph, nodo_novo)) %>% sample(1)
    ic(nodo_para_aceitar)
    u <- ic(runif(1))
    if(ic(u < p)) { # aceitar o vizinho
      graph %<>% add_edges(c(nodo_para_aceitar %>% as.integer(), nodo_novo))
    } else { # escolher outro sem ser o vizinho escolhido (ver nota)
      nodo_para_ligar <- 1:vcount(graph) %>%  
        # todos excepto o rejeitado, os já ligados e o próprio nodo novo
        setdiff(c(nodo_para_aceitar, get_neighbors(graph, nodo_novo), nodo_novo)) %>% 
        sample(1)
      graph %<>% add_edges(c(nodo_para_ligar, nodo_novo))
    }
  }
  graph
}
set.seed(1)
g %>% random_walk_model_iter() %>%  plot()
```

Nota: não me foi claro se ao rejeitar o vizinho:
- outro qualquer pode ser escolhido excepto o vizinho escolhido
- outro qualquer pode ser escolhido desde que não seja vizinho

Se for a segunda, começar com um clique parece impossivel, portanto decidi a primeira.

```{r}
set.seed(1)
g_dps <- g
# iterate until 200 nodes
for (i in 1:(200 - vcount(g))) {
  g_dps %<>% random_walk_model_iter(debug_ = F, i = i)
}
ic_enable()
ic(vcount(g_dps) == 200)
ic(is.simple(g_dps))
ecount(g_dps) == 190*3 + ecount(g) |> ic()
g_dps %>% plot(vertex.size = 7, vertex.label.cex = 0.35)
```

```{r}
# fazer 10 redes com isto agr
set.seed(1)
graphs <- list()
for (i in 1:10) {
  g_dps <- g
  for (j in 1:(200 - vcount(g))) {
    g_dps %<>% random_walk_model_iter(debug_ = F, i = j)
  }
  graphs[[i]] <- g_dps
}
```

```{r}
graphs[[7]] %>% plot
```


```{r}
library(tibble)

# Função para calcular as métricas
calculate_metrics <- function(graph) {
  mean_distance <- mean_distance(graph, directed = FALSE, unconnected = TRUE)
  clustering_coef <- transitivity(graph, type = "global")
  deg <- degree(graph, mode = "all")
  ht <- mean(deg^2)/mean(deg)^2
  
  return(tibble(
    Mean_Distance = mean_distance,
    Clustering_Coefficient = clustering_coef,
    Heterogeneity = ht
  ))
}

# Calculando métricas para cada rede
metrics <- lapply(graphs, calculate_metrics)

# Criando uma tabela com os resultados
results_table <- tibble(
  Rede = 1:length(graphs),
  Distancia_Media = sapply(metrics, function(x) x$Mean_Distance),
  Coeficiente_de_Clustering = sapply(metrics, function(x) x$Clustering_Coefficient),
  Heterogeneidade = sapply(metrics, function(x) x$Heterogeneity)
)

results_table

```

Clique com 20 nodos

```{r}
graph.full(20, directed = F) -> g2

g2 |> plot()
```



```{r}
set.seed(1)
g2 %>% random_walk_model_iter() %>%  plot()
```
```{r}
set.seed(1)
g_dps2 <- g2
# iterate until 200 nodes
for (i in 1:(200 - vcount(g2))) {
  g_dps2 %<>% random_walk_model_iter(debug_ = F, i = i)
}
ic_enable()
ic(vcount(g_dps2) == 200)
ic(is.simple(g_dps2))
ecount(g_dps2) == 190*3 + ecount(g2) |> ic()
g_dps2 %>% plot(vertex.size = 7, vertex.label.cex = 0.35)
```
```{r}
# fazer 10 redes com isto agr
set.seed(1)
graphs <- list()
for (i in 1:10) {
  g_dps2 <- g2
  for (j in 1:(200 - vcount(g2))) {
    g_dps2 %<>% random_walk_model_iter(debug_ = F, i = j)
  }
  graphs[[i]] <- g_dps2
}
```

```{r}
graphs[[7]] %>% plot
```


```{r}
# Calculando métricas para cada rede
metrics2 <- lapply(graphs, calculate_metrics)

# Criando uma tabela com os resultados
results_table2 <- tibble(
  Rede = 1:length(graphs),
  Distancia_Media = sapply(metrics, function(x) x$Mean_Distance),
  Coeficiente_de_Clustering = sapply(metrics, function(x) x$Clustering_Coefficient),
  Heterogeneidade = sapply(metrics, function(x) x$Heterogeneity)
)

results_table2
```

